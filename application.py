import requests  # Added missing import for requests
import base64
from PIL import Image
import PIL
from typing import List, Dict, Any, Optional, Type, Callable
import plotly.graph_objects as go
import pandas as pd
import altair as alt
from datetime import datetime, timedelta
import uuid
from dotenv import load_dotenv
import json
import time
from langchain.schema.agent import AgentFinish
from langchain.tools import BaseTool, StructuredTool, Tool
from langchain.agents import AgentExecutor, create_structured_chat_agent
from langchain.chains import ConversationChain
from langchain.memory import ConversationBufferMemory
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.text_splitter import CharacterTextSplitter, RecursiveCharacterTextSplitter
from langchain.document_loaders import PyPDFLoader, UnstructuredPDFLoader
from langchain.prompts import PromptTemplate
from langchain.chains.summarize import load_summarize_chain
from langchain.document_loaders import Docx2txtLoader
import tempfile
import os
import streamlit as st

# Set page configuration at the very beginning
st.set_page_config(
    page_title="CareerCompass Pro",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)


# Try to load environment variables from .env file (for local development)
load_dotenv()


def get_api_key():
    # For testing purposes, return a mock API key
    # return "mock_api_key_for_testing"
    
    # Original implementation:
    # Then, check environment variables (for local development)
    if 'GOOGLE_API_KEY' in os.environ:
        return os.environ['GOOGLE_API_KEY']
        # First, check for API key in Streamlit secrets (for deployment)
    elif hasattr(st, 'secrets') and 'GOOGLE_API_KEY' in st.secrets:
        return st.secrets['GOOGLE_API_KEY']
    # If no key is found, return None
    else:
        return None

# Function to load and encode images for background


def get_base64_of_bin_file(bin_file):
    with open(bin_file, 'rb') as f:
        data = f.read()
    return base64.b64encode(data).decode()


def set_background(png_file):
    try:
        bin_str = get_base64_of_bin_file(png_file)
        page_bg_img = '''
        <style>
        .stApp {
            background-image: url("data:image/png;base64,%s");
            background-size: cover;
            background-position: center;
        }
        </style>
        ''' % bin_str
        st.markdown(page_bg_img, unsafe_allow_html=True)
    except:
        pass  # Skip if background file not available

# Enhanced LLM setup with caching


@st.cache_resource
def initialize_llm():
    api_key = get_api_key()

    if not api_key:
        return None
        
#     # For testing purposes, create a mock LLM that returns predefined responses
#     class MockLLM:
#         def invoke(self, prompt):
#             return type('obj', (object,), {
#                 'content': """
# # Resume Analysis

# ## Overview
# This is a well-structured resume that highlights your experience in software development and project management.

# ## Strengths
# - Clear organization with distinct sections
# - Good use of bullet points to highlight achievements
# - Relevant technical skills are listed
# - Education and certifications are well presented

# ## Areas for Improvement
# - Consider adding more quantifiable achievements
# - Some bullet points could be more concise
# - Add a brief professional summary at the top

# ## Skills Assessment
# - Technical Skills: Strong
# - Communication: Good
# - Leadership: Demonstrated through project management
# - Problem-solving: Evident in project descriptions

# ## Recommendations
# 1. Add metrics to demonstrate impact (e.g., improved efficiency by X%)
# 2. Tailor skills section to match job descriptions
# 3. Consider adding a brief professional summary
# 4. Ensure consistent formatting throughout

# ## ATS Compatibility
# Your resume appears to be ATS-friendly with clear section headings and standard formatting.
# """
#             })
    
#     # Return the mock LLM instead of the real one
#     return MockLLM()
    
    # Original implementation:
    return ChatGoogleGenerativeAI(
        model="gemini-1.5-flash",
        temperature=0.2,
        top_p=0.95,
        top_k=40,
        max_output_tokens=2048,
        google_api_key=api_key)


# Initialize LLM with API key and advanced parameters
llm = initialize_llm()

# Initialize conversation memory for contextual responses
# Changed from "chat_history" to "history"
memory = ConversationBufferMemory(memory_key="history")

# # Create a mock conversation chain for testing
# class MockConversation:
#     def __init__(self):
#         pass
        
#     def invoke(self, input_text):
#         return {
#             "response": "This is a mock response to your follow-up question. In a real application, this would be generated by the LLM based on your specific question and the context of the conversation."
#         }

# # Use the mock conversation instead of the real one
# conversation = MockConversation()

# Original implementation:
conversation = ConversationChain(
    llm=llm,
    memory=memory,
    verbose=True
)

# Advanced text splitter for better document processing
advanced_text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=1500,
    chunk_overlap=200,
    separators=["\n\n", "\n", ". ", " ", ""],
    keep_separator=True,
)

# Enhanced tools for the agent


class ResumeAnalysisTool(BaseTool):
    name: str = "resume_analyzer"  # Add type annotation
    # Add type annotation
    description: str = "Analyzes a resume for strengths, weaknesses, and improvement areas"

    def _run(self, resume_text: str) -> str:
        prompt = PromptTemplate.from_template(
            "You are an expert resume analyst. Analyze the following resume: {resume_text}"
        )
        return llm.invoke(prompt.format(resume_text=resume_text)).content

    def _arun(self, resume_text: str):
        raise NotImplementedError("This tool does not support async")


class JobMatchTool(BaseTool):
    name: str = "job_matcher"  # Add type annotation
    # Add type annotation
    description: str = "Evaluates how well a resume matches a job description"

    def _run(self, resume_text: str, job_description: str) -> str:
        prompt = PromptTemplate.from_template(
            "You are an expert job matcher. Evaluate how well this resume: {resume_text} " +
            "matches this job description: {job_description}. Provide a percentage match and detailed analysis."
        )
        return llm.invoke(prompt.format(
            resume_text=resume_text,
            job_description=job_description
        )).content

    def _arun(self, resume_text: str, job_description: str):
        raise NotImplementedError("This tool does not support async")


class JobRecommendationTool(BaseTool):
    name: str = "job_recommender"
    description: str = "Recommends job roles and industries based on a resume and optional preferences."

    def _run(self, resume_text: str, preferences: Optional[str] = None) -> str:
        prompt_template = """
        You are an expert career counselor. Based on the following resume:
        {resume_text}

        {preferences_info}

        Recommend 5-10 suitable job roles and industries. For each recommendation, provide:
        - Job Title
        - Industry
        - Key skills from the resume that align with this role
        - A brief explanation of why it's a good fit

        Format your recommendations clearly using markdown.
        """
        preferences_info = f"Consider the following preferences: {preferences}" if preferences else ""
        prompt = PromptTemplate.from_template(prompt_template).format(
            resume_text=resume_text,
            preferences_info=preferences_info
        )
        return llm.invoke(prompt).content

    def _arun(self, resume_text: str, preferences: Optional[str] = None):
        raise NotImplementedError("This tool does not support async")


class InterviewPreparationTool(BaseTool):
    name: str = "interview_preparer"
    description: str = "Generates interview questions and preparation tips based on a resume and optional job description."

    def _run(self, resume_text: str, job_description: Optional[str] = None) -> str:
        prompt_template = """
        You are an expert interview coach. Based on the following resume:
        {resume_text}

        {job_description_info}

        Generate 5-10 common interview questions tailored to the candidate's experience and the job requirements.
        Also, provide 3-5 key tips for preparing for an interview for such a role.

        Format your response clearly using markdown.
        """
        job_description_info = f"Consider this job description: {job_description}" if job_description else ""
        prompt = PromptTemplate.from_template(prompt_template).format(
            resume_text=resume_text,
            job_description_info=job_description_info
        )
        return llm.invoke(prompt).content

    def _arun(self, resume_text: str, job_description: Optional[str] = None):
        raise NotImplementedError("This tool does not support async")

# Add a helper function for consistent navigation sidebar


def add_navigation_sidebar():
    # Theme toggle - Moved to the top
    st.sidebar.markdown("### Theme")
    if 'theme' not in st.session_state:
        st.session_state['theme'] = 'light'

    theme_option = st.sidebar.radio("Select Theme", ('light', 'dark'), key='theme_selector')
    if theme_option != st.session_state['theme']:
        st.session_state['theme'] = theme_option
        st.rerun()

    st.sidebar.markdown("---") # Separator after theme

    st.sidebar.markdown("## Navigation")

    # Dashboard button
    if st.sidebar.button("Dashboard", key="nav_dashboard", use_container_width=True):
        st.session_state['current_page'] = "dashboard"
        st.rerun()

    # Resume Analysis button
    if st.sidebar.button("Resume Analysis", key="nav_resume_analysis", use_container_width=True):
        st.session_state['current_page'] = "resume_analysis"
        st.rerun()

    # Resume Generator button
    if st.sidebar.button("Resume Generator", key="nav_resume_generator", use_container_width=True):
        st.session_state['current_page'] = "resume_generator"
        st.rerun()

    # Cover Letter Generator button
    if st.sidebar.button("Cover Letter Generator", key="nav_cover_letter", use_container_width=True):
        st.session_state['current_page'] = "cover_letter_generator"
        st.rerun()

    # Resume-Job Matcher button
    if st.sidebar.button("Resume-Job Matcher", key="nav_resume_job_matcher", use_container_width=True):
        st.session_state['current_page'] = "resume_job_matcher"
        st.rerun()

    # Job Recommendation button
    if st.sidebar.button("Job Recommendation", key="nav_job_recommendation", use_container_width=True):
        st.session_state['current_page'] = "job_recommendation"
        st.rerun()

    # Interview Preparation button
    if st.sidebar.button("Interview Preparation", key="nav_interview_preparation", use_container_width=True):
        st.session_state['current_page'] = "interview_preparation"
        st.rerun()

    st.sidebar.markdown("---")

    # Global resume uploader
    st.sidebar.markdown("## Upload Resume")
    uploaded_file = st.sidebar.file_uploader(
        "Upload your resume once for all tools", type=["pdf", "docx"], key="global_uploader")
    if uploaded_file:
        st.session_state.uploaded_resume = uploaded_file
        st.sidebar.success(f"Uploaded: {uploaded_file.name}")


if 'current_page' not in st.session_state:
    st.session_state['current_page'] = "dashboard"
if 'activity_log' not in st.session_state:
    st.session_state['activity_log'] = []
if 'analysis_results' not in st.session_state:
    st.session_state['analysis_results'] = None
if 'key_insights' not in st.session_state:
    st.session_state['key_insights'] = None
if 'uploaded_resume' not in st.session_state:
    st.session_state['uploaded_resume'] = None
if 'job_description_text' not in st.session_state:
    st.session_state['job_description_text'] = ""
if 'job_recommendation_text' not in st.session_state:
    st.session_state['job_recommendation_text'] = ""
if 'interview_preparation_job_description' not in st.session_state:
    st.session_state['interview_preparation_job_description'] = ""


# Function to log user activity
def log_activity(activity: str):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    st.session_state.activity_log.insert(0, {
        "date": timestamp,
        "activity": activity,
        "status": "Complete"
    })


def process_docx(docx_file):
    # We need to modify this too to handle Streamlit uploads
    with tempfile.NamedTemporaryFile(delete=False, suffix='.docx') as tmp_file:
        tmp_file.write(docx_file.getvalue())
        tmp_path = tmp_file.name

    loader = Docx2txtLoader(tmp_path)
    text = loader.load_and_split()

    # Clean up the temporary file
    os.unlink(tmp_path)
    return text


def process_pdf(pdf_file):
    text = ""
    # Create a temporary file to save the uploaded PDF
    with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp_file:
        tmp_file.write(pdf_file.getvalue())
        tmp_path = tmp_file.name

    # Try UnstructuredPDFLoader first for better parsing of complex PDFs
    try:
        loader = UnstructuredPDFLoader(tmp_path)
        pages = loader.load()

        # If the UnstructuredPDFLoader fails to parse content properly, fall back to PyPDFLoader
        if not any(page.page_content for page in pages):
            raise ValueError("UnstructuredPDFLoader returned empty content")

        for page in pages:
            text += page.page_content

    except Exception as e:
        # Fallback to PyPDFLoader
        loader = PyPDFLoader(tmp_path)
        pages = loader.load()

        for page in pages:
            text += page.page_content

    text = text.replace('\t', ' ')

    # Use advanced text splitter for better chunk quality
    texts = advanced_text_splitter.create_documents([text])

    # Clean up the temporary file
    os.unlink(tmp_path)

    return texts

# New function for resume improvement with job-specific optimization


def generate_improved_resume(resume_text, target_job=None, style="modern"):
    prompt_template = """
    You are a professional resume writer with expertise in creating impactful, ATS-friendly resumes.
    
    Based on the following resume content:
    {resume_text}
    
    Create an improved, professionally formatted resume in the {style} style that:
    1. Emphasizes key achievements and quantifiable results
    2. Uses strong action verbs and industry-specific keywords
    3. Optimizes for ATS systems with appropriate keyword placement
    4. Follows modern resume best practices
    5. Maintains all original information but presents it more effectively
    6. Improves layout and organization for better readability
    7. Ensures proper formatting with clear section headers
    
    {job_target_info}
    
    Format the resume sections with proper markdown and ensure it's ready for professional use.
    Include a Skills section that highlights technical, soft, and transferable skills relevant to their career.
    
    Your response MUST be in markdown format suitable for professional presentation.
    """

    job_target_text = ""
    if target_job:
        job_target_text = f"""Target the resume specifically for this job description or industry: {target_job}
        Analyze the job description to identify key requirements and ensure relevant skills and experiences are 
        highlighted prominently. Include industry-specific keywords from the job description."""

    prompt = PromptTemplate.from_template(prompt_template).format(
        resume_text=resume_text,
        job_target_info=job_target_text,
        style=style
    )

    try:
        response = llm.invoke(prompt)
        return response.content
    except Exception as e:
        st.error(f"Error generating resume: {str(e)}")
        return "Error generating resume. Please try again."

# PDF generation function
def markdown_to_pdf(markdown_content, filename="resume.pdf"):
    """Convert markdown content to PDF using weasyprint"""
    try:
        import markdown
        from weasyprint import HTML, CSS
        from io import BytesIO
        
        # Convert markdown to HTML
        html_content = markdown.markdown(markdown_content)
        
        # Add basic CSS styling for professional look
        css_content = """
        @page {
            margin: 1in;
            size: letter;
        }
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 8.5in;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        h2 {
            color: #34495e;
            margin-top: 25px;
            margin-bottom: 15px;
        }
        h3 {
            color: #2c3e50;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        p, li {
            margin-bottom: 8px;
        }
        ul {
            padding-left: 20px;
        }
        strong {
            color: #2c3e50;
        }
        hr {
            border: none;
            border-top: 1px solid #bdc3c7;
            margin: 20px 0;
        }
        """
        
        # Create full HTML document
        full_html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Resume</title>
        </head>
        <body>
            {html_content}
        </body>
        </html>
        """
        
        # Generate PDF
        pdf_buffer = BytesIO()
        HTML(string=full_html).write_pdf(pdf_buffer, stylesheets=[CSS(string=css_content)])
        pdf_buffer.seek(0)
        
        return pdf_buffer.getvalue()
        
    except Exception as e:
        st.error(f"Error generating PDF: {str(e)}")
        return None

# Enhanced cover letter generation with tone and style options


def generate_cover_letter(resume_text, job_description, company_info, tone="professional"):
    prompt_template = """
    You are a professional cover letter writer with expertise in creating compelling, personalized cover letters.
    
    Based on:
    
    RESUME:
    {resume_text}
    
    JOB DESCRIPTION:
    {job_description}
    
    COMPANY INFORMATION:
    {company_info}
    
    TONE REQUESTED: 
    {tone}
    
    Create a compelling cover letter that:
    1. Is personalized to the specific job and company
    2. Highlights relevant experience from the resume that matches the job description
    3. Demonstrates understanding of the company's values and goals
    4. Uses a {tone} tone throughout
    5. Includes a strong attention-grabbing opening
    6. Provides specific examples of achievements relevant to the role
    7. Includes a confident closing with a clear call to action
    8. Is between 250-350 words
    
    Format the cover letter professionally with proper salutation, paragraphs, and signature.
    Your response MUST be in markdown format suitable for professional presentation.
    """

    prompt = PromptTemplate.from_template(prompt_template).format(
        resume_text=resume_text,
        job_description=job_description,
        company_info=company_info,
        tone=tone
    )

    try:
        response = llm.invoke(prompt)
        return response.content
    except Exception as e:
        st.error(f"Error generating cover letter: {str(e)}")
        return "Error generating cover letter. Please try again."


# AI-powered function to extract structured insights from analysis text
def extract_key_insights(analysis_text: str) -> Dict[str, Any]:
    prompt = f"""
    You are an expert in parsing and structuring information. From the following resume analysis, extract the key insights in JSON format. The JSON object should include:
    - "strengths": A list of 3-5 key strengths.
    - "weaknesses": A list of 2-4 areas for improvement.
    - "scores": A dictionary of scores (Overall, Format, Content, ATS Compatibility) from 0-100.

    Analysis Text:
    {analysis_text}

    Respond with ONLY the JSON object.
    """
    try:
        response = llm.invoke(prompt).content
        # Clean up the response to ensure it is valid JSON
        json_response = response.strip()
        if json_response.startswith('```json'):
            json_response = json_response[7:-3].strip()
        insights = json.loads(json_response)
        return insights
    except Exception as e:
        st.error(f"Error extracting insights: {e}")
        return None


# Resume visualization function


def generate_skills_chart(analysis_text):
    # Extract skills from the analysis
    try:
        skills_section = ""
        sections = analysis_text.split("##")
        for section in sections:
            if "Skills" in section or "Key Skills" in section:
                skills_section = section
                break

        if not skills_section:
            # If no explicit skills section, use the whole text
            skills_section = analysis_text

        # Extract skills as bullet points
        skills = []
        lines = skills_section.split('\n')
        for line in lines:
            if line.strip().startswith('- ') or line.strip().startswith('* '):
                skill = line.strip()[2:].strip()
                # Avoid long text that's probably not a skill
                if skill and len(skill) < 50:
                    skills.append(skill)

        if len(skills) < 3:
            # Fallback: ask LLM to extract skills
            prompt = f"Extract a list of professional skills from this text. Respond with only the skills as a JSON array: {skills_section}"
            response = llm.invoke(prompt).content
            try:
                # Try to extract JSON array from the response
                start_idx = response.find('[')
                end_idx = response.rfind(']') + 1
                if start_idx >= 0 and end_idx > start_idx:
                    json_str = response[start_idx:end_idx]
                    skills = json.loads(json_str)
                    skills = skills[:10]  # Limit to top 10 skills
            except:
                # If JSON parsing fails, use default skills
                skills = ["Communication", "Leadership", "Problem Solving"]

        # Generate random scores for visualization (in a real app, these would be derived from analysis)
        import random
        scores = [random.randint(60, 95) for _ in range(len(skills))]

        # Create DataFrame for visualization
        df = pd.DataFrame({
            'Skill': skills[:8],  # Limit to 8 skills for better visualization
            'Score': scores[:8]
        })

        # Create radar chart using plotly
        fig = go.Figure()

        fig.add_trace(go.Scatterpolar(
            r=df['Score'],
            theta=df['Skill'],
            fill='toself',
            fillcolor='rgba(79, 139, 249, 0.3)',
            line=dict(color='#4F8BF9', width=2),
            name='Skills Assessment'
        ))

        fig.update_layout(
            polar=dict(
                radialaxis=dict(
                    visible=True,
                    range=[0, 100]
                )
            ),
            paper_bgcolor='rgba(0,0,0,0)',
            plot_bgcolor='rgba(0,0,0,0)',
            showlegend=False,
            height=400,
        )

        return fig
    except Exception as e:
        print(f"Error generating skills chart: {str(e)}")
        return None

# Add animation helper for UI elements


def load_lottie_animation(url):
    r = requests.get(url)
    if r.status_code != 200:
        return None
    return r.json()

# UI components - Custom cards


def create_metric_card(title, value, delta=None):
    st.markdown(
        f"""
        <div style="background-color:white; border-radius:10px; padding:15px; margin-bottom:20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <h4 style="color:#333; margin:0;">{title}</h4>
            <h2 style="color:#4F8BF9; margin:5px 0;">{value}</h2>
            {f'<p style="color:{"green" if delta > 0 else "red"}; margin:0;">{delta}%</p>' if delta is not None else ''}
        </div>
        """,
        unsafe_allow_html=True
    )

# Enhanced login interface


def show_login_page():
    col1, col2, col3 = st.columns([1, 2, 1])

    with col2:
        st.markdown(
            '<div class="title-container"><h1>CareerCompass Pro</h1><p>Login to access premium career tools</p></div>', unsafe_allow_html=True)

        with st.form("login_form"):
            st.markdown("""
            <style>
            div[data-testid="stForm"] {
                background-color: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            }
            div[data-testid="stFormSubmitButton"] > button {
                background-color: #4F8BF9;
                width: 100%;
                margin-top: 20px;
            }
            </style>
            """, unsafe_allow_html=True)

            st.image(
                "https://img.icons8.com/fluent/80/000000/user-male-circle.png", width=80)
            email = st.text_input("Email", key="login_email")
            password = st.text_input(
                "Password", type="password", key="login_password")

            col1, col2 = st.columns([1, 1])
            with col1:
                st.checkbox("Remember me")
            with col2:
                st.markdown(
                    '<p style="text-align:right;"><a href="#">Forgot password?</a></p>', unsafe_allow_html=True)

            submit = st.form_submit_button("Login")

            if submit:
                with st.spinner("Authenticating..."):
                    time.sleep(1)  # Simulate authentication delay
                    if email in MOCK_USERS and MOCK_USERS[email]["password"] == password:
                        st.session_state['user_authenticated'] = True
                        st.session_state['user_email'] = email
                        st.session_state['user_id'] = MOCK_USERS[email]["id"]
                        st.session_state['current_page'] = "dashboard"
                        st.rerun()
                    else:
                        st.error("Invalid email or password")

        st.markdown("---")
        st.markdown(
            '<div style="text-align:center;">Don\'t have an account?</div>', unsafe_allow_html=True)

        if st.button("Create an account", use_container_width=True):
            st.session_state['current_page'] = "signup"
            st.rerun()

# Signup page


def show_signup_page():
    st.markdown('<div class="title-container"><h1>CareerCompass Pro</h1><p>Create your account</p></div>',
                unsafe_allow_html=True)

    with st.form("signup_form"):
        email = st.text_input("Email")
        password = st.text_input("Password", type="password")
        confirm_password = st.text_input("Confirm Password", type="password")
        submit = st.form_submit_button("Sign Up")

        if submit:
            if password != confirm_password:
                st.error("Passwords do not match")
            elif email in MOCK_USERS:
                st.error("Email already registered")
            else:
                # In a real app, securely hash the password before storing
                MOCK_USERS[email] = {
                    "password": password, "id": str(uuid.uuid4())}
                st.success("Account created! You can now log in.")
                st.session_state['current_page'] = "login"
                st.rerun()

    st.markdown("---")
    if st.button("Already have an account? Login"):
        st.session_state['current_page'] = "login"
        st.rerun()

# Subscription page


def show_subscription_page():
    st.markdown('<div class="title-container"><h1>Choose Your Plan</h1><p>Select a subscription that fits your job search timeline</p></div>', unsafe_allow_html=True)

    col1, col2, col3 = st.columns(3)

    with col1:
        st.markdown("""
        <div style="border:1px solid #ddd; padding: 20px; border-radius: 10px; height: 360px;">
            <h3>2-Week Access</h3>
            <h2>$14.99</h2>
            <p>Perfect for quick job applications</p>
            <ul>
                <li>Resume Analysis & Optimization</li>
                <li>Cover Letter Generation</li>
                <li>Interview Preparation</li>
                <li>2-Week Access</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Select 2-Week Plan"):
            success, end_date = validate_subscription(
                st.session_state['user_id'], "2-week")
            if success:
                st.session_state['subscription_active'] = True
                st.session_state['subscription_end_date'] = end_date
                st.session_state['current_page'] = "dashboard"
                st.rerun()

    with col2:
        st.markdown("""
        <div style="border:1px solid #4f8bf9; padding: 20px; border-radius: 10px; background-color: #f8f9fe; height: 360px;">
            <h3>Monthly Access</h3>
            <h2>$29.99</h2>
            <p><strong>Most Popular</strong></p>
            <ul>
                <li>Resume Analysis & Optimization</li>
                <li>Cover Letter Generation</li>
                <li>Interview Preparation</li>
                <li>30-Day Access</li>
                <li>Priority Support</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Select Monthly Plan"):
            success, end_date = validate_subscription(
                st.session_state['user_id'], "monthly")
            if success:
                st.session_state['subscription_active'] = True
                st.session_state['subscription_end_date'] = end_date
                st.session_state['current_page'] = "dashboard"
                st.rerun()

    with col3:
        st.markdown("""
        <div style="border:1px solid #ddd; padding: 20px; border-radius: 10px; height: 360px;">
            <h3>Annual Access</h3>
            <h2>$199.99</h2>
            <p>Best Value</p>
            <ul>
                <li>Resume Analysis & Optimization</li>
                <li>Cover Letter Generation</li>
                <li>Interview Preparation</li>
                <li>365-Day Access</li>
                <li>Priority Support</li>
                <li>Job Search Tracking</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Select Annual Plan"):
            success, end_date = validate_subscription(
                st.session_state['user_id'], "annual")
            if success:
                st.session_state['subscription_active'] = True
                st.session_state['subscription_end_date'] = end_date
                st.session_state['current_page'] = "dashboard"
                st.rerun()


# Mock user database (replace with actual database in production)
MOCK_USERS = {
    "user@example.com": {"password": "password123", "id": "user123"}
}

# Mock subscription validation (replace with actual payment processor integration)


def validate_subscription(user_id, plan_type):
    # In a real app, call payment processor API to validate payment
    # For demo, always return success
    today = datetime.now()

    if plan_type == "2-week":
        end_date = today + timedelta(days=14)
    elif plan_type == "monthly":
        end_date = today + timedelta(days=30)
    elif plan_type == "annual":
        end_date = today + timedelta(days=365)
    else:
        return False, None

    return True, end_date

# Custom Dashboard Metrics


def calculate_resume_metrics(user_id):
    # In a real app, these would come from a database
    metrics = {
        "resume_score": 78,
        "industry_avg": 65,
        "improvement": 12,
        "keyword_match": 82,
        "format_score": 90,
        "areas_to_improve": 3
    }
    return metrics

# Enhanced Dashboard with analytics


def show_dashboard():
    add_navigation_sidebar()

    st.markdown('<div class="title-container"><h1>Welcome to CareerCompass Pro</h1><p>Your all-in-one career toolkit</p></div>', unsafe_allow_html=True)

    # Resume metrics (in a real app, these would come from actual analysis)
    metrics = calculate_resume_metrics(st.session_state['user_id'])

    # Display metrics in a modern dashboard layout
    st.markdown("## Resume Analytics")
    if st.session_state.key_insights:
        scores = st.session_state.key_insights.get("scores", {})
        col1, col2, col3 = st.columns(3)
        with col1:
            create_metric_card("Overall Score", f"{scores.get('Overall', 'N/A')}")
        with col2:
            create_metric_card("Format Score", f"{scores.get('Format', 'N/A')}")
        with col3:
            create_metric_card("Content Score", f"{scores.get('Content', 'N/A')}")
    else:
        st.info(
            "No resume analysis found. Upload your resume in the 'Resume Analysis' tab to see your scores.")

    # Add charts
    st.markdown("## Your Skills Analysis")
    st.info("Upload your resume in Resume Analysis to generate your personalized skills visualization")

    # Main tools section
    st.markdown("## Career Tools")
    col1, col2, col3 = st.columns(3)

    with col1:
        # Make the cards clickable with enhanced styling
        st.markdown("""
        <div style="border:1px solid #4F8BF9; padding:20px; border-radius:10px; text-align:center; 
                   cursor:pointer; background-color:white; height:220px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <img src="" style="width:48px; margin-bottom:10px;">
            <h3 style="color:#4F8BF9;">Resume Analysis</h3>
            <p>Get comprehensive feedback and insights on your current resume</p>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Go to Resume Analysis", key="goto_resume_analysis", use_container_width=True):
            st.session_state['current_page'] = "resume_analysis"
            st.rerun()

    with col2:
        st.markdown("""
        <div style="border:1px solid #4F8BF9; padding:20px; border-radius:10px; text-align:center; 
                   cursor:pointer; background-color:white; height:220px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <img src="" style="width:48px; margin-bottom:10px;">
            <h3 style="color:#4F8BF9;">Resume Generator</h3>
            <p>Create an optimized, ATS-friendly version of your resume</p>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Go to Resume Generator", key="goto_resume_generator", use_container_width=True):
            st.session_state['current_page'] = "resume_generator"
            st.rerun()

    with col3:
        st.markdown("""
        <div style="border:1px solid #4F8BF9; padding:20px; border-radius:10px; text-align:center; 
                   cursor:pointer; background-color:white; height:220px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <img src="" style="width:48px; margin-bottom:10px;">
            <h3 style="color:#4F8BF9;">Cover Letter Generator</h3>
            <p>Generate targeted cover letters for specific job applications</p>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Go to Cover Letter Generator", key="goto_cover_letter", use_container_width=True):
            st.session_state['current_page'] = "cover_letter_generator"
            st.rerun()

    col4, col5, col6 = st.columns(3)
    with col4:
        st.markdown("""
        <div style="border:1px solid #4F8BF9; padding:20px; border-radius:10px; text-align:center; 
                   cursor:pointer; background-color:white; height:220px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <img src="" style="width:48px; margin-bottom:10px;">
            <h3 style="color:#4F8BF9;">Resume-Job Matcher</h3>
            <p>Evaluate how well your resume matches a job description</p>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Go to Resume-Job Matcher", key="goto_resume_job_matcher", use_container_width=True):
            st.session_state['current_page'] = "resume_job_matcher"
            st.rerun()

    with col5:
        st.markdown("""
        <div style="border:1px solid #4F8BF9; padding:20px; border-radius:10px; text-align:center; 
                   cursor:pointer; background-color:white; height:220px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <img src="" style="width:48px; margin-bottom:10px;">
            <h3 style="color:#4F8BF9;">Job Recommendation</h3>
            <p>Get personalized job recommendations based on your resume</p>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Go to Job Recommendation", key="goto_job_recommendation", use_container_width=True):
            st.session_state['current_page'] = "job_recommendation"
            st.rerun()

    with col6:
        st.markdown("""
        <div style="border:1px solid #4F8BF9; padding:20px; border-radius:10px; text-align:center; 
                   cursor:pointer; background-color:white; height:220px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <img src="" style="width:48px; margin-bottom:10px;">
            <h3 style="color:#4F8BF9;">Interview Preparation</h3>
            <p>Generate tailored interview questions and tips</p>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Go to Interview Preparation", key="goto_interview_preparation", use_container_width=True):
            st.session_state['current_page'] = "interview_preparation"
            st.rerun()

    # Recent activity section (would be populated from database in real app)
    st.markdown("## Recent Activity")
    if st.session_state.activity_log:
        st.table(pd.DataFrame(st.session_state.activity_log).head(5))
    else:
        st.info("No recent activity. Get started by using one of the tools above!")

# Enhanced Resume Generator page with style selection


def show_resume_generator():
    add_navigation_sidebar()

    st.markdown('<div class="title-container"><h1>Resume Generator</h1><p>Create an optimized version of your resume</p></div>', unsafe_allow_html=True)

    # Add a back button to return to dashboard
    col_back, col_spacer = st.columns([1, 5])
    with col_back:
        if st.button("‚Üê Back to Dashboard", key="back_to_dashboard_from_generator"):
            st.session_state['current_page'] = "dashboard"
            st.rerun()

    # Use tabs for different resume generator options
    tab1, tab2 = st.tabs(["Basic Generator", "Advanced Generator"])

    with tab1:
        target_job = st.text_area(
            "Enter the job title or description you're targeting (optional)", height=100)

        if st.session_state.uploaded_resume and st.button("Generate Improved Resume", use_container_width=True):
            with st.spinner("Analyzing and improving your resume..."):
                uploaded_file = st.session_state.uploaded_resume
                if uploaded_file.name.endswith('.docx'):
                    text = process_docx(uploaded_file)
                    resume_text = "\n".join([doc.page_content for doc in text])
                else:
                    text = process_pdf(uploaded_file)
                    resume_text = "\n".join([doc.page_content for doc in text])

                improved_resume = generate_improved_resume(
                    resume_text, target_job, "modern")

                st.success("Resume successfully improved!")
                log_activity(f"Generated improved resume for {uploaded_file.name}")
                with st.expander("View Improved Resume", expanded=True):
                    st.markdown(improved_resume)

                # Download options
                col1, col2 = st.columns(2)
                with col1:
                    st.download_button(
                        label="Download as Markdown",
                        data=improved_resume,
                        file_name="improved_resume.md",
                        mime="text/markdown",
                        use_container_width=True
                    )
                with col2:
                    # Generate PDF and offer download
                    pdf_data = markdown_to_pdf(improved_resume)
                    if pdf_data:
                        st.download_button(
                            label="Download as PDF",
                            data=pdf_data,
                            file_name="improved_resume.pdf",
                            mime="application/pdf",
                            use_container_width=True
                        )
                    else:
                        st.button("PDF Generation Failed", disabled=True, use_container_width=True)
        elif not st.session_state.uploaded_resume:
            st.warning("Please upload a resume in the sidebar to use this feature.")

    with tab2:
        st.markdown("### Advanced Resume Generator")

        col1, col2 = st.columns(2)
        with col1:
            target_job = st.text_area(
                "Job Description (for targeting)", height=150)
        with col2:
            style = st.selectbox("Resume Style",
                                 ["Modern", "Traditional", "Creative",
                                     "Executive", "Technical"],
                                 index=0)

        st.markdown("### Resume Sections")
        col1, col2, col3 = st.columns(3)
        with col1:
            include_summary = st.checkbox("Professional Summary", value=True)
        with col2:
            include_skills = st.checkbox("Skills Section", value=True)
        with col3:
            include_achievements = st.checkbox("Key Achievements", value=True)

        if st.session_state.uploaded_resume and st.button("Generate Advanced Resume", use_container_width=True):
            with st.spinner("Creating your optimized resume..."):
                uploaded_file = st.session_state.uploaded_resume
                if uploaded_file.name.endswith('.docx'):
                    text = process_docx(uploaded_file)
                    resume_text = "\n".join([doc.page_content for doc in text])
                else:
                    text = process_pdf(uploaded_file)
                    resume_text = "\n".join([doc.page_content for doc in text])

                improved_resume = generate_improved_resume(
                    resume_text, target_job, style.lower())

                st.success("Premium resume successfully generated!")
                log_activity(
                    f"Generated advanced resume ({style}) for {uploaded_file.name}")

                tab1, tab2 = st.tabs(["Preview", "ATS Analysis"])

                with tab1:
                    st.markdown(improved_resume)

                with tab2:
                    st.info("ATS Compatibility Analysis")

                    # In a real implementation, this would be actual ATS analysis
                    ats_score = 92
                    st.progress(ats_score/100)
                    st.markdown(f"**ATS Compatibility Score:** {ats_score}%")

                    st.markdown("**Keyword Matches:**")
                    st.json({
                        "project management": "Found",
                        "team leadership": "Found",
                        "agile": "Found",
                        "data analysis": "Not Found - Consider Adding",
                        "strategic planning": "Found"
                    })

                # Download options
                col1, col2 = st.columns(2)
                with col1:
                    st.download_button(
                        label="Download as Markdown",
                        data=improved_resume,
                        file_name="premium_resume.md",
                        mime="text/markdown",
                        use_container_width=True
                    )
                with col2:
                    # Generate PDF and offer download
                    pdf_data = markdown_to_pdf(improved_resume)
                    if pdf_data:
                        st.download_button(
                            label="Download as PDF",
                            data=pdf_data,
                            file_name="premium_resume.pdf",
                            mime="application/pdf",
                            use_container_width=True
                        )
                    else:
                        st.button("PDF Generation Failed", disabled=True, use_container_width=True)
        elif not st.session_state.uploaded_resume:
            st.warning("Please upload a resume in the sidebar to use this feature.")

# Enhanced Cover Letter Generator with tone selection


def show_cover_letter_generator():
    add_navigation_sidebar()

    st.markdown('<div class="title-container"><h1>Cover Letter Generator</h1><p>Create targeted cover letters for specific job applications</p></div>', unsafe_allow_html=True)

    # Add a back button to return to dashboard
    col_back, col_spacer = st.columns([1, 5])
    with col_back:
        if st.button("‚Üê Back to Dashboard", key="back_to_dashboard_from_cover_letter"):
            st.session_state['current_page'] = "dashboard"
            st.rerun()

    # Enhanced UI with sections
    st.markdown("### Your Information")

    if not st.session_state.uploaded_resume:
        st.warning("Please upload a resume in the sidebar to generate a cover letter.")
        return

    st.success(f"Using resume: {st.session_state.uploaded_resume.name}")

    tone = st.selectbox("Cover Letter Tone",
                        ["Professional", "Enthusiastic",
                         "Confident", "Formal", "Conversational"],
                        index=0)

    st.markdown("### Job Information")
    job_description = st.text_area("Paste the job description", height=150)

    st.markdown("### Company Research")
    company_info = st.text_area(
        "Enter information about the company (culture, values, mission, etc.)", height=100)

    col1, col2, col3 = st.columns(3)
    with col1:
        include_salary = st.checkbox(
            "Include salary expectations", value=False)
    with col2:
        include_availability = st.checkbox(
            "Include availability date", value=False)
    with col3:
        include_references = st.checkbox("Mention references", value=False)

    if job_description and st.button("Generate Cover Letter", use_container_width=True):
        with st.spinner("Creating your personalized cover letter..."):
            uploaded_file = st.session_state.uploaded_resume
            if uploaded_file.name.endswith('.docx'):
                text = process_docx(uploaded_file)
                resume_text = "\n".join([doc.page_content for doc in text])
            else:
                text = process_pdf(uploaded_file)
                resume_text = "\n".join([doc.page_content for doc in text])

            cover_letter = generate_cover_letter(
                resume_text, job_description, company_info, tone.lower())

            st.success("Cover letter successfully generated!")
            log_activity(f"Generated cover letter for {uploaded_file.name}")

            # Use tabs for different views
            tab1, tab2 = st.tabs(["Preview", "Format Options"])

            with tab1:
                st.markdown(cover_letter)

            with tab2:
                st.markdown("### Formatting Options")
                st.radio("Font Style", [
                         "Modern", "Traditional", "Professional"])
                st.radio("Salutation", [
                         "Dear Hiring Manager", "Dear Recruiter", "To Whom It May Concern"])

            # Download options with columns for better layout
            col1, col2 = st.columns(2)
            with col1:
                st.download_button(
                    label="Download as Markdown",
                    data=cover_letter,
                    file_name="cover_letter.md",
                    mime="text/markdown",
                    use_container_width=True
                )
            with col2:
                # Generate PDF and offer download
                pdf_data = markdown_to_pdf(cover_letter)
                if pdf_data:
                    st.download_button(
                        label="Download as PDF",
                        data=pdf_data,
                        file_name="cover_letter.pdf",
                        mime="application/pdf",
                        use_container_width=True
                    )
                else:
                    st.button("PDF Generation Failed", disabled=True, use_container_width=True)

# Enhanced Resume Analysis with visualizations


def show_resume_analysis():
    add_navigation_sidebar()

    st.markdown('<div class="title-container"><h1>Resume Analysis</h1><p>Get detailed feedback on your current resume</p></div>', unsafe_allow_html=True)

    # Add a back button to return to dashboard
    col_back, col_spacer = st.columns([1, 5])
    with col_back:
        if st.button("‚Üê Back to Dashboard", key="back_to_dashboard_from_analysis"):
            st.session_state['current_page'] = "dashboard"
            st.rerun()

    # Main content area with two columns
    col1, col2 = st.columns([1, 2])

    with col1:
        st.markdown("### Your Uploaded Resume")
        if st.session_state.uploaded_resume:
            uploaded_file = st.session_state.uploaded_resume
            st.success(f"Ready to analyze: {uploaded_file.name}")
            file_details = {
                "Filename": uploaded_file.name,
                "File size": f"{uploaded_file.size / 1024:.2f} KB",
                "File type": uploaded_file.type
            }
            for key, value in file_details.items():
                st.text(f"{key}: {value}")

            if st.button("Analyze Resume", use_container_width=True):
                st.session_state.analysis_triggered = True
        else:
            st.warning("Please upload a resume in the sidebar to begin analysis.")

        target_job = ""

    # Main column for results
    with col2:
        if st.session_state.get('analysis_triggered'):
            with st.spinner("Analyzing your resume..."):
                uploaded_file = st.session_state.uploaded_resume
                progress_bar = st.progress(0)

                # Process the file based on extension
                file_extension = uploaded_file.name.split(".")[-1]

                progress_bar.progress(25)
                time.sleep(0.5)  # Simulate processing time

                if file_extension == "docx":
                    text = process_docx(uploaded_file)
                elif file_extension == "pdf":
                    text = process_pdf(uploaded_file)
                else:
                    st.error(
                        "Unsupported file type. Please upload a PDF or DOCX file.")
                    st.markdown('</div>', unsafe_allow_html=True)
                    return

                progress_bar.progress(50)
                time.sleep(0.5)  # Simulate processing time

                # Setup enhanced prompts with more detailed instructions
                prompt_template_str = """
                You are a professional CV analyzer with expertise in resume evaluation and career coaching.
                Write a detailed analysis of the following resume content:
                {text}
                """

                # Create a proper PromptTemplate object with only the text variable
                prompt = PromptTemplate(
                    template=prompt_template_str,
                    input_variables=["text"]
                )

                # Handle target job separately after chain execution if needed
                resume_content = "\n".join([doc.page_content for doc in text])

                # For testing purposes, skip the actual chain execution and use a mock result
                # Original implementation:
                chain = load_summarize_chain(
                    llm=llm,
                    chain_type="stuff",
                    prompt=prompt,
                    input_key="input_documents",
                    output_key="output_text",
                )

                # Call our mock chain function
                result = chain({"input_documents": text}, return_only_outputs=True)

                # If target job is specified, we can add this information to the output
                if target_job:
                    job_prompt = f"\n\n## Target Job Analysis\nAdditional analysis for target job: {target_job}"
                    result['output_text'] += job_prompt

                # Log the activity and store results in session state
                log_activity(f"Analyzed resume: {uploaded_file.name}")
                st.session_state.analysis_results = result['output_text']
                st.session_state.key_insights = extract_key_insights(
                    result['output_text'])

                progress_bar.progress(100)
                time.sleep(0.5)  # Simulate completion

                # Hide the progress elements
                progress_bar.empty()

                # Reset the trigger
                st.session_state.analysis_triggered = False

        if st.session_state.analysis_results:
            # Parse the result into sections
            output_text = st.session_state.analysis_results
            sections = output_text.split('##')

            # Create tabs for different views of the analysis
            tab1, tab2, tab3 = st.tabs(
                ["Analysis", "Insights", "Visualization"])

            with tab1:
                # Display a success message
                st.success(
                    "Analysis complete! Review your personalized career guidance below.")

                # Process each section with better styling
                for section in sections:
                    if section.strip():  # Skip empty sections
                        lines = section.strip().split('\n', 1)
                        if len(lines) > 0:
                            section_title = lines[0].strip()
                            section_content = lines[1].strip() if len(
                                lines) > 1 else ""

                            # Special handling for Name and Email sections
                            if section_title.lower() == "name" or section_title.lower() == "email":
                                st.markdown(
                                    f"<h3 class='section-header'>{section_title}</h3>", unsafe_allow_html=True)
                                st.markdown(
                                    f"<p>{section_content}</p>", unsafe_allow_html=True)
                                if section_title.lower() == "email":
                                    st.markdown(
                                        "<hr>", unsafe_allow_html=True)
                            else:
                                # Create an expander for other sections
                                with st.expander(f"{section_title}", expanded=False):
                                    st.markdown(section_content)

            with tab2:
                # Create a summary of key insights
                st.subheader("Key Insights")

                if st.session_state.key_insights:
                    insights = st.session_state.key_insights
                    col1, col2 = st.columns(2)
                    with col1:
                        st.markdown("### Strengths")
                        for strength in insights.get("strengths", []):
                            st.success(strength)

                    with col2:
                        st.markdown("### Areas for Improvement")
                        for weakness in insights.get("weaknesses", []):
                            st.warning(weakness)

                    # Resume Scores
                    st.markdown("### Resume Score")
                    scores = insights.get("scores", {})
                    if scores:
                        for category, score in scores.items():
                            st.progress(score / 100)
                            st.caption(f"{category}: {score}%")
                    else:
                        st.info("No scores were extracted from the analysis.")
                else:
                    st.info(
                        "Could not extract key insights. View the full analysis in the 'Analysis' tab.")

            with tab3:
                # Generate skill visualization
                st.subheader("Skills Visualization")

                skills_chart = generate_skills_chart(output_text)
                if skills_chart:
                    st.plotly_chart(skills_chart, use_container_width=True)
                else:
                    st.info(
                        "Skills visualization could not be generated. Please check the analysis for skills information.")

            # Add download options
            st.download_button(
                label="Download Analysis as Text",
                data=st.session_state.analysis_results,
                file_name=f"career_analysis_{st.session_state.uploaded_resume.name.split('.')[0]}.txt",
                mime="text/plain"
            )

            # Add option for follow-up questions
            st.markdown("### Have questions about your analysis?")
            follow_up = st.text_input(
                "Ask a follow-up question about your resume or the analysis")

            if follow_up:
                with st.spinner("Generating response..."):
                    # Use the conversation chain for context-aware responses
                    conversation.memory.save_context(
                        # First 1000 chars for context
                        {"input": f"Resume analysis: {output_text[:1000]}..."},
                        {"output": "I've analyzed this resume."}
                    )

                    response = conversation.predict(input=follow_up)
                    st.write(response)
        else:
            st.info("Upload your resume and click 'Analyze Resume' to see the results.")


def show_resume_job_matcher():
    add_navigation_sidebar()

    st.markdown('<div class="title-container"><h1>Resume-Job Matcher</h1><p>Evaluate how well your resume matches a job description</p></div>', unsafe_allow_html=True)

    col_back, col_spacer = st.columns([1, 5])
    with col_back:
        if st.button("‚Üê Back to Dashboard", key="back_to_dashboard_from_matcher"):
            st.session_state['current_page'] = "dashboard"
            st.rerun()

    st.markdown("### Your Resume")
    if st.session_state.uploaded_resume:
        st.success(f"Using resume: {st.session_state.uploaded_resume.name}")
    else:
        st.warning("Please upload a resume in the sidebar to use this feature.")
        return

    st.markdown("### Job Description")
    job_description = st.text_area("Paste the job description here", height=200, key="job_description_input", value=st.session_state.job_description_text)
    st.session_state.job_description_text = job_description # Update session state

    if st.button("Analyze Match", use_container_width=True):
        if not st.session_state.uploaded_resume or not job_description:
            st.error("Please upload a resume and paste a job description to analyze.")
            return

        with st.spinner("Analyzing resume-job match..."):
            uploaded_file = st.session_state.uploaded_resume
            if uploaded_file.name.endswith('.docx'):
                text = process_docx(uploaded_file)
                resume_text = "\n".join([doc.page_content for doc in text])
            else:
                text = process_pdf(uploaded_file)
                resume_text = "\n".join([doc.page_content for doc in text])

            job_match_tool = JobMatchTool()
            match_analysis = job_match_tool._run(resume_text, job_description)

            st.success("Match analysis complete!")
            log_activity(f"Performed resume-job match for {uploaded_file.name}")

            st.markdown("### Match Analysis Results")
            st.markdown(match_analysis)

            st.download_button(
                label="Download Match Analysis",
                data=match_analysis,
                file_name=f"resume_job_match_analysis_{uploaded_file.name.split('.')[0]}.md",
                mime="text/markdown"
            )

            st.markdown("---")
            st.markdown("### Have more questions about the match?")
            follow_up = st.text_input("Ask a follow-up question about the match analysis", key="match_follow_up")

            if follow_up:
                with st.spinner("Generating response..."):
                    conversation.memory.save_context(
                        {"input": f"Resume-Job Match Analysis: {match_analysis[:1000]}..."},
                        {"output": "I've analyzed the match."}
                    )
                    response = conversation.predict(input=follow_up)
                    st.write(response)


def show_job_recommendation():
    add_navigation_sidebar()

    st.markdown('<div class="title-container"><h1>Job Recommendation</h1><p>Get personalized job recommendations based on your resume</p></div>', unsafe_allow_html=True)

    col_back, col_spacer = st.columns([1, 5])
    with col_back:
        if st.button("‚Üê Back to Dashboard", key="back_to_dashboard_from_recommendation"):
            st.session_state['current_page'] = "dashboard"
            st.rerun()

    st.markdown("### Your Resume")
    if st.session_state.uploaded_resume:
        st.success(f"Using resume: {st.session_state.uploaded_resume.name}")
    else:
        st.warning("Please upload a resume in the sidebar to use this feature.")
        return

    st.markdown("### Your Preferences (Optional)")
    preferences = st.text_area("e.g., 'remote roles in tech', 'marketing jobs in New York'", height=100, key="job_preferences_input", value=st.session_state.job_recommendation_text)
    st.session_state.job_recommendation_text = preferences # Update session state

    if st.button("Get Job Recommendations", use_container_width=True):
        if not st.session_state.uploaded_resume:
            st.error("Please upload a resume to get job recommendations.")
            return

        with st.spinner("Generating job recommendations..."):
            uploaded_file = st.session_state.uploaded_resume
            if uploaded_file.name.endswith('.docx'):
                text = process_docx(uploaded_file)
                resume_text = "\n".join([doc.page_content for doc in text])
            else:
                text = process_pdf(uploaded_file)
                resume_text = "\n".join([doc.page_content for doc in text])

            job_recommender_tool = JobRecommendationTool()
            recommendations = job_recommender_tool._run(resume_text, preferences)

            st.success("Job recommendations generated!")
            log_activity(f"Generated job recommendations for {uploaded_file.name}")

            st.markdown("### Recommended Job Roles and Industries")
            st.markdown(recommendations)

            st.download_button(
                label="Download Recommendations",
                data=recommendations,
                file_name=f"job_recommendations_{uploaded_file.name.split('.')[0]}.md",
                mime="text/markdown"
            )

            st.markdown("---")
            st.markdown("### Have more questions about these recommendations?")
            follow_up = st.text_input("Ask a follow-up question about the job recommendations", key="recommendation_follow_up")

            if follow_up:
                with st.spinner("Generating response..."):
                    conversation.memory.save_context(
                        {"input": f"Job Recommendations: {recommendations[:1000]}..."},
                        {"output": "I've provided job recommendations."}
                    )
                    response = conversation.predict(input=follow_up)
                    st.write(response)


def show_interview_preparation():    
    add_navigation_sidebar()    
    
    st.markdown('<div class="title-container"><h1>Interview Preparation</h1><p>Generate tailored interview questions and tips</p></div>', unsafe_allow_html=True)    
    col_back, col_spacer = st.columns([1, 5])    
    with col_back:        
        if st.button("‚Üê Back to Dashboard", key="back_to_dashboard_from_interview"):            
            st.session_state['current_page'] = "dashboard"            
            st.rerun()    
    
    st.markdown("### Your Resume")    
    if st.session_state.uploaded_resume:        
        st.success(f"Using resume: {st.session_state.uploaded_resume.name}")    
    else:        
        st.warning("Please upload a resume in the sidebar to use this feature.")        
        return    
    
    st.markdown("### Target Job Description (Optional)")    
    job_description = st.text_area("Paste the job description here to tailor questions", height=150, key="interview_job_description_input", value=st.session_state.interview_preparation_job_description)    
    st.session_state.interview_preparation_job_description = job_description # Update session state    
    
    if st.button("Generate Interview Prep", use_container_width=True):        
        if not st.session_state.uploaded_resume:            
            st.error("Please upload a resume to generate interview preparation materials.")            
            return        
        with st.spinner("Generating interview questions and tips..."):            
            uploaded_file = st.session_state.uploaded_resume            
            if uploaded_file.name.endswith('.docx'):                
                text = process_docx(uploaded_file)                
                resume_text = "\n".join([doc.page_content for doc in text])            
            else:                
                text = process_pdf(uploaded_file)                
                resume_text = "\n".join([doc.page_content for doc in text])            
                
            interview_tool = InterviewPreparationTool()            
            preparation_content = interview_tool._run(resume_text, job_description)            
            
            st.success("Interview preparation content generated!")            
            log_activity(f"Generated interview prep for {uploaded_file.name}")            
            
            st.markdown("### Interview Questions and Tips")            
            st.markdown(preparation_content)            
            
            st.download_button(                
                label="Download Interview Prep",                
                data=preparation_content,                
                file_name=f"interview_prep_{uploaded_file.name.split('.')[0]}.md",                
                mime="text/markdown"            
                )           
             
            st.markdown("---")            
            st.markdown("### Have more questions about interview prep?")            
            follow_up = st.text_input("Ask a follow-up question about the interview preparation", key="interview_follow_up")            
            
            if follow_up:                
                with st.spinner("Generating response..."):                    
                    conversation.memory.save_context(                        
                        {"input": f"Interview Preparation: {preparation_content[:1000]}..."},                        
                        {"output": "I've provided interview preparation content."}                    
                    )                    
                    response = conversation.predict(input=follow_up)                    
                    st.write(response)

def main():
    # Try to set a background image for enhanced visual appeal
    # set_background("/path/to/background.png")  # Uncomment and provide path if available

    # Add custom CSS with enhanced styling
    st.markdown("""
    <style>
    /* CSS Variables for theming */
    :root {
        --primary-color: #4f8bf9;
        --secondary-color: #6a5acd;
        --background-light: #f0f2f6;
        --background-card-light: #ffffff;
        --text-color-light: #333;
        --header-color-light: #2c3e50;
        --border-color-light: #e0e0e0;
        --shadow-color-light: rgba(0, 0, 0, 0.08);
        --sidebar-bg-light: #2c3e50;
        --sidebar-text-light: white;
        --button-bg-light: var(--primary-color);
        --button-hover-light: #3a7bd5;
        --tab-bg-light: #e9ecef;
        --tab-hover-light: #dee2e6;
        --tab-selected-light: var(--primary-color);
        --alert-success-bg-light: #d4edda;
        --alert-success-text-light: #155724;
        --alert-success-border-light: #c3e6cb;
        --alert-warning-bg-light: #fff3cd;
        --alert-warning-text-light: #856404;
        --alert-warning-border-light: #ffeeba;
        --alert-error-bg-light: #f8d7da;
        --alert-error-text-light: #721c24;
        --alert-error-border-light: #f5c6cb;
    }

    .dark-theme {
        --primary-color: #91a8ed; /* Lighter blue for dark mode */
        --secondary-color: #b19cd9; /* Lighter purple for dark mode */
        --background-light: #1a1a2e; /* Dark background */
        --background-card-light: #2a2a4a; /* Darker card background */
        --text-color-light: #e0e0e0; /* Light text */
        --header-color-light: #f0f0f0; /* Lighter headings */
        --border-color-light: #444466;
        --shadow-color-light: rgba(0, 0, 0, 0.3);
        --sidebar-bg-light: #0f0f1a;
        --sidebar-text-light: #e0e0e0;
        --button-bg-light: var(--primary-color);
        --button-hover-light: #7b92d1;
        --tab-bg-light: #3a3a5a;
        --tab-hover-light: #4a4a6a;
        --tab-selected-light: var(--primary-color);
        --alert-success-bg-light: #28a745;
        --alert-success-text-light: #ffffff;
        --alert-success-border-light: #218838;
        --alert-warning-bg-light: #ffc107;
        --alert-warning-text-light: #343a40;
        --alert-warning-border-light: #e0a800;
        --alert-error-bg-light: #dc3545;
        --alert-error-text-light: #ffffff;
        --alert-error-border-light: #c82333;
    }

    /* General Body and Layout */
    body {
        font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        color: var(--text-color-light);
        line-height: 1.6;
        background-color: var(--background-light);
        transition: background-color 0.3s ease, color 0.3s ease;
    }
    .main {
        background-color: var(--background-light); /* Light gray background */
        padding: 2rem;
        border-radius: 8px;
        box-shadow: 0 4px 20px var(--shadow-color-light);
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
    }

    /* Headers */
    h1, h2, h3, h4, h5, h6 {
        color: var(--header-color-light); /* Darker blue-gray for headings */
        font-weight: 600;
        margin-top: 1.5rem;
        margin-bottom: 0.8rem;
        transition: color 0.3s ease;
    }
    h1 {
        font-size: 2.5rem;
        border-bottom: 2px solid var(--primary-color);
        padding-bottom: 10px;
    }
    h2 {
        font-size: 2rem;
        color: var(--primary-color); /* Main accent color for subheadings */
    }

    /* Title Container (Hero Section) */
    .title-container {
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); /* Gradient background */
        padding: 2rem 1.5rem;
        border-radius: 12px;
        margin-bottom: 2.5rem;
        color: white;
        text-align: center;
        box-shadow: 0 8px 25px var(--shadow-color-light);
        animation: fadeIn 1s ease-out;
        transition: background 0.3s ease, box-shadow 0.3s ease;
    }
    .title-container h1 {
        color: white;
        border-bottom: none;
        font-size: 3rem;
        margin-bottom: 0.5rem;
        text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
    }
    .title-container p {
        font-size: 1.2rem;
        opacity: 0.9;
    }

    /* Cards and Containers */
    .st-emotion-cache-1njps74.e1f1d6gn0 { /* Target Streamlit's main block container */
        background-color: var(--background-card-light);
        padding: 2rem;
        border-radius: 10px;
        box-shadow: 0 4px 15px var(--shadow-color-light);
        margin-bottom: 2rem;
        border-left: 6px solid var(--primary-color); /* Accent border */
        transition: background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
    }
    .st-emotion-cache-1njps74.e1f1d6gn0:hover {
        box-shadow: 0 6px 20px var(--shadow-color-light);
        transform: translateY(-2px);
        transition: all 0.3s ease-in-out;
    }

    /* Metric Cards */
    div[data-testid="stVerticalBlock"] > div > div > div[data-testid="stMarkdownContainer"] > div {
        background-color: var(--background-card-light);
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 4px 10px var(--shadow-color-light);
        border: 1px solid var(--border-color-light);
        transition: background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
    }
    div[data-testid="stVerticalBlock"] > div > div > div[data-testid="stMarkdownContainer"] > div h4 {
        color: var(--text-color-light);
        margin: 0;
        font-size: 1.1rem;
        transition: color 0.3s ease;
    }
    div[data-testid="stVerticalBlock"] > div > div > div[data-testid="stMarkdownContainer"] > div h2 {
        color: var(--primary-color);
        margin: 5px 0;
        font-size: 2.2rem;
        transition: color 0.3s ease;
    }
    div[data-testid="stVerticalBlock"] > div > div > div[data-testid="stMarkdownContainer"] > div p {
        font-size: 0.9rem;
        margin: 0;
        color: var(--text-color-light);
        transition: color 0.3s ease;
    }

    /* Buttons */
    .stButton > button {
        background-color: var(--button-bg-light);
        color: white;
        border: none;
        border-radius: 8px;
        padding: 0.6rem 1.5rem;
        font-weight: bold;
        font-size: 1.05rem;
        transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
        box-shadow: 0 4px 10px var(--shadow-color-light);
    }
    .stButton > button:hover {
        background-color: var(--button-hover-light);
        transform: translateY(-1px);
        box-shadow: 0 6px 15px var(--shadow-color-light);
    }
    .stButton > button:active {
        transform: translateY(0);
        box-shadow: 0 2px 5px var(--shadow-color-light);
    }

    /* Text Inputs and Text Areas */
    .stTextInput > div > div > input, .stTextArea > div > div > textarea {
        border-radius: 8px;
        border: 1px solid var(--border-color-light);
        padding: 10px 15px;
        box-shadow: inset 0 1px 3px var(--shadow-color-light);
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease, color 0.3s ease;
        background-color: var(--background-card-light);
        color: var(--text-color-light);
    }
    .stTextInput > div > div > input:focus, .stTextArea > div > div > textarea:focus {
        border-color: var(--primary-color);
        box-shadow: 0 0 0 0.2rem rgba(79, 139, 249, 0.25);
        outline: none;
    }

    /* Selectbox */
    .stSelectbox > div > div {
        border-radius: 8px;
        border: 1px solid var(--border-color-light);
        box-shadow: inset 0 1px 3px var(--shadow-color-light);
        background-color: var(--background-card-light);
        color: var(--text-color-light);
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }

    /* Expander Styling */
    div.stExpander > div:first-child {
        background-color: var(--tab-bg-light); /* Light gray for expander header */
        border-left: 5px solid var(--secondary-color); /* Purple accent */
        border-radius: 8px;
        padding: 0.8rem 1rem;
        font-weight: 600;
        color: var(--header-color-light);
        margin-bottom: 0.5rem;
        transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }
    div.stExpander > div:nth-child(2) {
        background-color: var(--background-card-light);
        border: 1px solid var(--border-color-light);
        border-top: none;
        border-radius: 0 0 8px 8px;
        padding: 1.2rem;
        margin-left: 5px; /* Align with border-left of header */
        transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    /* Tabs */
    .stTabs [data-baseweb="tab-list"] {
        gap: 8px;
        margin-bottom: 1.5rem;
    }
    .stTabs [data-baseweb="tab"] {
        background-color: var(--tab-bg-light);
        border-radius: 8px 8px 0px 0px;
        padding: 12px 20px;
        font-weight: 600;
        color: var(--text-color-light);
        transition: all 0.3s ease;
    }
    .stTabs [data-baseweb="tab"]:hover {
        background-color: var(--tab-hover-light);
        color: var(--header-color-light);
    }
    .stTabs [aria-selected="true"] {
        background-color: var(--tab-selected-light);
        color: white;
        box-shadow: 0 2px 8px var(--shadow-color-light);
    }

    /* Sidebar */
    .sidebar .sidebar-content {
        background-color: var(--sidebar-bg-light); /* Dark blue-gray for sidebar */
        color: var(--sidebar-text-light);
        transition: background-color 0.3s ease, color 0.3s ease;
    }
    .sidebar .stButton > button {
        background-color: var(--secondary-color); /* Purple for sidebar buttons */
        width: 100%;
        margin-bottom: 10px;
        transition: background-color 0.3s ease;
    }
    .sidebar .stButton > button:hover {
        background-color: var(--button-hover-light);
    }

    /* Alerts/Messages */
    .stAlert {
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }
    .stAlert.success {
        background-color: var(--alert-success-bg-light);
        color: var(--alert-success-text-light);
        border-color: var(--alert-success-border-light);
    }
    .stAlert.warning {
        background-color: var(--alert-warning-bg-light);
        color: var(--alert-warning-text-light);
        border-color: var(--alert-warning-border-light);
    }
    .stAlert.error {
        background-color: var(--alert-error-bg-light);
        color: var(--alert-error-text-light);
        border-color: var(--alert-error-border-light);
    }

    /* Progress Bar */
    .stProgress > div > div > div > div {
        background-color: var(--primary-color);
        border-radius: 8px;
        transition: background-color 0.3s ease;
    }

    /* Table/DataFrame */
    .dataframe {
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 10px var(--shadow-color-light);
        transition: box-shadow 0.3s ease;
    }
    .dataframe thead th {
        background-color: var(--primary-color);
        color: white;
        padding: 12px 15px;
        text-align: left;
        font-weight: 600;
        transition: background-color 0.3s ease;
    }
    .dataframe tbody tr:nth-child(even) {
        background-color: var(--background-light);
        transition: background-color 0.3s ease;
    }
    .dataframe tbody td {
        padding: 10px 15px;
        border-bottom: 1px solid var(--border-color-light);
        transition: border-color 0.3s ease;
    }
    .dataframe tbody tr:last-child td {
        border-bottom: none;
    }

    /* Animations */
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    </style>
    """, unsafe_allow_html=True)

    # Check if API key is available
    api_key = get_api_key()
    if not api_key:
        st.error(
            "Google API Key not found. Please set up your API key in Streamlit secrets or environment variables.")
        st.info("For local development: Add GOOGLE_API_KEY to your .env file\nFor Streamlit deployment: Add GOOGLE_API_KEY to your app secrets")
        return

    # Bypass authentication for testing
    st.session_state['user_authenticated'] = True
    st.session_state['subscription_active'] = True
    if st.session_state['user_authenticated'] and 'user_id' not in st.session_state:
        st.session_state['user_id'] = "test_user" # Initialize with a default user ID for testing
    
    # Set default page if not set
    if 'current_page' not in st.session_state:
        st.session_state['current_page'] = "dashboard"
    
    # Route to the appropriate page based on current_page
    if st.session_state['current_page'] == "dashboard":
        show_dashboard()
    elif st.session_state['current_page'] == "resume_analysis":
        show_resume_analysis()
    elif st.session_state['current_page'] == "resume_generator":
        show_resume_generator()
    elif st.session_state['current_page'] == "cover_letter_generator":
        show_cover_letter_generator()
    elif st.session_state['current_page'] == "resume_job_matcher":
        show_resume_job_matcher()
    elif st.session_state['current_page'] == "job_recommendation":
        show_job_recommendation()
    elif st.session_state['current_page'] == "interview_preparation":
        show_interview_preparation()
    else:
        # Default to dashboard if unknown page
        st.session_state['current_page'] = "dashboard"
        show_dashboard()


if __name__ == "__main__":
    main()